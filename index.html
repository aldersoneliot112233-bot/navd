<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>¬°Feliz Navidad! ‚ùÑÔ∏è</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #0a0f2c;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
      position: fixed;
      width: 100%;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    .mensaje {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      padding: 26px;
      max-width: 90%;
      background: rgba(10, 15, 40, 0.35);
      border-radius: 20px;
      backdrop-filter: blur(3px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100%;
    }
    .mensaje h2 {
      font-size: 22px;
      margin-bottom: 14px;
      color: #ffd700;
      text-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
    }
    .mensaje p {
      font-size: 18px;
      line-height: 1.5;
      opacity: 0.96;
    }
    .mensaje em {
      color: #ff9e9e;
      font-style: normal;
    }

    /* ‚ú® BOT√ìN DE MELOD√çA */
    .melody-btn {
      position: absolute;
      top: 12px;
      right: 16px;
      background: rgba(255, 255, 255, 0.15);
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      color: #ffd700;
      font-size: 22px;
      cursor: pointer;
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s, background 0.2s;
      z-index: 11;
    }
    .melody-btn:hover {
      transform: scale(1.1);
      background: rgba(255, 255, 255, 0.25);
    }
  </style>
</head>
<body>
  <div class="mensaje">
    <h2>Para <em>Mary </em> üíå</h2>
    <p>
      Que esta noche te regale<br>
      risas que salen del alma,<br>
      abrazos que calientan el pecho<br>
      y un momentico de calma que te haga sonre√≠r.<br><br>
      
      Que los d√≠as buenos se acerquen<br>
      y los malos se vayan con el viento.<br><br>
      
      Disfruta cada lucecita,<br>
      cada canci√≥n, cada ‚Äúte quiero‚Äù.<br>
      Porque hoy, el mundo brilla un poquito m√°s‚Ä¶<br>
      ¬°Y tuuu formas parte de ese brillo! ‚ú®<br><br>
      
      ¬°Feliz Navidad y pr√≥spero A√±o Nuevo! üéÑ‚ú®üåüüí´
    </p>
    <!-- ‚ú® BOT√ìN DE M√öSICA DENTRO DEL MENSAJE -->
    <button class="melody-btn" id="melodyBtn">üéµ</button>
  </div>
  <canvas id="navidad"></canvas>

  <script>
    const canvas = document.getElementById('navidad');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ===== NIEVE ACUMULADA (copos que ya cayeron) =====
    const landedSnowflakes = [];

    // ===== COPITOS DE NIEVE ACTIVOS + TRAILS =====
    class Snowflake {
      constructor() {
        this.reset();
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.03;
        this.trail = [];
        this.trailLength = 8;
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * -200;
        this.size = Math.random() * 5 + 2;
        this.speed = Math.random() * 1.8 + 0.6;
        this.wind = (Math.random() - 0.5) * 0.9;
        this.landed = false;
        this.trail = [];
      }

      draw() {
        if (this.landed) return;

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < this.trail.length; i++) {
          const t = this.trail[i];
          const alpha = (i / this.trail.length) * 0.6;
          ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.lineWidth = this.size * 0.4;
          ctx.beginPath();
          ctx.moveTo(t.x, t.y);
          ctx.lineTo(t.x + Math.cos(this.rotation) * 2, t.y + Math.sin(this.rotation) * 2);
          ctx.stroke();
        }
        ctx.restore();

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.99)';
        ctx.lineWidth = 1.2;
        ctx.lineCap = 'round';
        const s = this.size;
        for (let i = 0; i < 6; i++) {
          ctx.rotate(Math.PI / 3);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(0, -s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, -s * 0.5);
          ctx.lineTo(-s * 0.25, -s * 0.75);
          ctx.moveTo(0, -s * 0.5);
          ctx.lineTo(s * 0.25, -s * 0.75);
          ctx.stroke();
        }
        ctx.restore();
      }

      update() {
        if (this.landed) return;

        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.trailLength) {
          this.trail.shift();
        }

        this.y += this.speed;
        this.x += this.wind;
        this.rotation += this.rotationSpeed;

        if (this.y >= canvas.height) {
          this.landed = true;
          landedSnowflakes.push({
            x: this.x,
            y: canvas.height,
            size: this.size,
            rotation: this.rotation
          });
          this.reset();
        }
      }
    }

    const snowflakes = [];
    const MAX_SNOWFLAKES = 160;
    for (let i = 0; i < MAX_SNOWFLAKES; i++) {
      snowflakes.push(new Snowflake());
    }

    // ===== FUEGOS ARTIFICIALES + TRAILS LARGOS =====
    const fireworks = [];
    const COLORS = [
      '#ff0000', '#ff9900', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#cc00ff', '#ff00ff'
    ];

    class Firework {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.particles = [];
        this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        this.life = 60;

        for (let i = 0; i < 50; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 3 + 1;
          this.particles.push({
            x: 0,
            y: 0,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            alpha: 1,
            size: Math.random() * 2 + 1,
            trail: []
          });
        }
      }

      update() {
        this.life--;
        if (this.life <= 0) return false;

        this.particles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.05;

          p.trail.push({ x: p.x, y: p.y, alpha: p.alpha });
          if (p.trail.length > 10) {
            p.trail.shift();
          }

          p.alpha -= 0.02;
        });

        return true;
      }

      draw() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        this.particles.forEach(p => {
          if (p.alpha > 0) {
            for (let i = 0; i < p.trail.length - 1; i++) {
              const t1 = p.trail[i];
              const t2 = p.trail[i + 1];
              const alpha = t1.alpha * 0.5;
              ctx.strokeStyle = `rgba(${parseInt(this.color.slice(1, 3), 16)}, ${parseInt(this.color.slice(3, 5), 16)}, ${parseInt(this.color.slice(5, 7), 16)}, ${alpha})`;
              ctx.lineWidth = p.size * 0.6;
              ctx.beginPath();
              ctx.moveTo(this.x + t1.x, this.y + t1.y);
              ctx.lineTo(this.x + t2.x, this.y + t2.y);
              ctx.stroke();
            }

            ctx.fillStyle = `rgba(${parseInt(this.color.slice(1, 3), 16)}, ${parseInt(this.color.slice(3, 5), 16)}, ${parseInt(this.color.slice(5, 7), 16)}, ${p.alpha})`;
            ctx.beginPath();
            ctx.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        ctx.restore();
      }
    }

    let fireworkTimer = 0;
    const FIREWORK_INTERVAL = 1500;

    function spawnFirework() {
      const x = Math.random() * canvas.width;
      const y = Math.random() * (canvas.height * 0.4) + 50;
      fireworks.push(new Firework(x, y));
    }

    // ‚ú® ===== M√öSICA DE NAVIDAD =====
    const melodyBtn = document.getElementById('melodyBtn');
    const bgMusic = new Audio('Feliz%20Navidad.mp3');
    bgMusic.loop = true;
    bgMusic.volume = 0.4;
    let isPlaying = false;

    melodyBtn.addEventListener('click', () => {
      if (isPlaying) {
        bgMusic.pause();
        melodyBtn.textContent = 'üéµ';
        isPlaying = false;
      } else {
        bgMusic.play().then(() => {
          melodyBtn.textContent = 'üéß';
          isPlaying = true;
        }).catch(e => {
          alert('No se pudo reproducir la m√∫sica. Int√©ntalo en otro navegador.');
        });
      }
    });

    // ===== BUCLE PRINCIPAL =====
    function animate() {
      ctx.fillStyle = '#0a0f2c';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      landedSnowflakes.forEach(flake => {
        ctx.save();
        ctx.translate(flake.x, flake.y);
        ctx.rotate(flake.rotation);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.98)';
        ctx.lineWidth = 1.1;
        const s = flake.size;
        for (let i = 0; i < 6; i++) {
          ctx.rotate(Math.PI / 3);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(0, -s);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, -s * 0.5);
          ctx.lineTo(-s * 0.25, -s * 0.75);
          ctx.moveTo(0, -s * 0.5);
          ctx.lineTo(s * 0.25, -s * 0.75);
          ctx.stroke();
        }
        ctx.restore();
      });

      for (let i = fireworks.length - 1; i >= 0; i--) {
        const fw = fireworks[i];
        fw.update();
        fw.draw();
        if (!fw.update()) {
          fireworks.splice(i, 1);
        }
      }

      snowflakes.forEach(flake => {
        flake.update();
        flake.draw();
      });

      fireworkTimer += 16;
      if (fireworkTimer >= FIREWORK_INTERVAL) {
        spawnFirework();
        fireworkTimer = 0;
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>